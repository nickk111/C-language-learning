## 什么是MySQL？

MySQL是一个关系型数据库是二维表存储的，有行有列。

SQLite（是进程内的数据库，即不同进程写不同的SQLite，只能访问本进程的DB数据，不涉及开server这个操作。MySQL区别于其他关系型数据库很大的一个特定就是支持插件式的存储引擎，支持如lnnoDB，MylSAM，Memory等。

MySQL，SQLserver，oracle都设计成C/S模型 mysql-server，mysql-client（多个进程请求同一个mysql-server）

### 你对数据库的范式是怎么理解的？数据库的三大范式

遵循范式的直接好处是减少数据的冗余存储。

**第一范式1NF：**确保表的**每一列都是不可分割的**基本数据单元，比如说用户地址，应该拆分成省、市、区、详细信息等 4 个字段。

**第二范式2NF：**在 1NF 的基础上，要求数据库表中的每一列都和主键直接相关，而不能只与主键的某一部分相关。

举个例子。假定选课关系表为`student_course`(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。

应该拆分成三个表：学生：`student`(stuent_no, student_name, 年龄)；课程：`course`(course_name, credit)；选课关系：`student_course_relation`(student_no, course_name, grade)。

**第三范式3NF：**在 2NF 的基础上，消除非主键列对主键的传递依赖，即非主键列只依赖于主键列，不依赖于其他非主键列。

假定学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。

可以把学生关系表分为如下两个表：学生：(student_no, student_name, age, academy_id)；学院：(academy_id, academy_telephone)。

**2NF和3NF的区别？**

- 2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。
- 3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。

### 存储引擎是什么？

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。

存储引擎是基于表的，而不是基于库的，可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

mysql是插件式的存储引擎，存储引擎可更换，支持不同类型的存储引擎；我们创建的表有3个东西：表的结构，数据，表的索引。怎么存储，存储方式是什么？这就是存储引擎直接影响上面内容的存储方式。

InnoDB 存储引擎在事务支持、并发性能、崩溃恢复等方面具有优势，支持自动增长列，外键等功能，索引采用聚集索引，索引和数据存储在同一个文件，所以InnoDB的表在磁盘上有两个文件，其文件名都和表名相同，扩展名分别是：.frm（存储表的定义）.ibd（存储数据和索引），在InnoDB你创建一个表，没有加主键，它自动给你加主键，因为数据和索引是一起存放的。

MyISAM 不支持事务、行级锁，外键，索引采用非聚集索引，其优势是访问的速度快，对事务完整性没有要求，以 SELECT、INSERT 为主的应用基本上都可以使用这个存储引擎来创建表。MyISAM的表在磁盘上存储成 3 个文件，其文件名都和表名相同，扩展名分别是：.frm（存储表定义）.MYD（MYData，存储数据）.MYI （MYIndex，存储索引）

Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。**默认使用** HASH 索引（不适合做范围查询）。

### InnoDB 和 MyISAM 有什么区别？

MySQL 5.7之前，默认存储引擎是 MyISAM，5.7之后是 InnoDB。

**① 存储结构**

- MyISAM：用三种格式的文件来存储，.frm 文件存储表的定义；.MYD 存储数据；.MYI 存储索引。
- InnoDB：用两种格式的文件来存储，.frm 文件存储表的定义；.ibd 存储数据和索引。

**② 事务支持**

- MyISAM：不支持事务。
- InnoDB：支持事务。

**③ 最小锁粒度**

- MyISAM：表级锁，高并发中写操作存在性能瓶颈。
- InnoDB：行级锁，并发写入性能高。

**④ 索引类型**

MyISAM 为非聚簇索引，索引和数据分开存储，索引保存的是数据文件的指针。也就是说索引关键字和数据没有在一起存放，体现在磁盘上，就是索引在一个文件存储，数据在另一个文件存储。

InnoDB 为聚集索引，数据和索引存放在一块。

**⑤ 外键支持**：MyISAM 不支持外键；InnoDB 支持外键。

**⑥ 主键必需**：MyISAM 表可以没有主键；InnoDB 表必须有主键。

## 索引

### 什么是索引？

索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。

索引一般存储在磁盘的文件中，它是占用物理空间的。

### 索引的优缺点？

优点：**加快数据查找的速度**

缺点：索引并非越多越好，过多的索引会导致CPU使用率居高不下，由于数据的改变，会造成索引文件的改动，过多的磁盘I/O造成CPU负荷太重  

### 索引的作用？

数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。索引文件相较于数据库文件，体积小得多，查到索引之后再映射到数据库记录，查询效率就会高很多。

### 什么情况下需要建索引？

1. 经常用于查询的字段
2. 经常用于连接的字段建立索引，可以加快连接的速度
3. 经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度

### 什么情况下不建索引？

1. `where`条件中用不到的字段不适合建立索引
2. 表记录较少。比如只有几百条数据，没必要加索引。
3. 需要经常增删改。需要评估是否适合加索引
4. **参与列计算**的列不适合建索引
5. **区分度不高**的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。

### 索引的数据结构

索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。

**B+树索引**

B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ 树中，节点中的 `key` 从左到右递增排列，如果某个指针的左右相邻 `key` 分别是 key~i~ 和 key~i+1~，则该指针指向节点的所有 `key` 大于等于 key~i~ 且小于等于 key~i+1~。

![image-20250805094755745](./MySQL面试题.assets/image-20250805094755745.png)

进行查找操作时，首先在根节点进行二分查找，找到`key`所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出`key`所对应的数据项。

MySQL 数据库使用最多的索引类型是`BTREE`索引，底层基于B+树数据结构来实现。

**哈希索引**

哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。

### Hash索引和B+树索引的区别？

- 哈希索引**不支持排序**，因为哈希表是无序的。
- 哈希索引**不支持范围查找**。
- 哈希索引**不支持模糊查询**及多列索引的最左前缀匹配。
- 因为哈希表中会**存在哈希冲突**，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。

### B树和B+树的区别？

![image-20250805095008606](./MySQL面试题.assets/image-20250805095008606.png)

**数据存储方式**：在B树中，每个节点都包含键和对应的值，叶子节点存储了实际的数据记录；而B+树中，仅仅只有叶子节点存储了实际的数据记录，非叶子节点只包含键信息和指向子节点的指针。

**数据检索方式**：在B树中，由于非叶子节点也存储了数据，所以查询时可以直接在非叶子节点找到对应的数据，具有更短的查询路径; 而B+树的所有数据都存储在叶子节点上，只有通过子节点才能获取到完整的数据。

**范围查询效率**：由于B+树的所有数据都存储在叶子节点上，并且叶子节点之间使用链表连接，所以范围查询的效率比较高。而在B树中，范围查询需要通过遍历多个层级的节点，效率相对较低。

**适用场景**：B树适合进行随机读写操作，因为每个节点都包含了数据。而B+树适合进行范围查询和顺序访问，因为数据都存储在叶子节点上，并且叶子节点之间使用链表连接，便于进行顺序遍历。

### 为什么B+树比B树更适合实现数据库索引？

- 由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。
- B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。
- B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

### 索引有什么分类？

**按数据结构分类：**B+树索引、Hash 索引

**按物理存储分类：**聚簇索引、非聚簇索引

**按字段特性分类：**主键索引、唯一索引、普通索引、前缀索引

**按字段个数分类：**单列索引、多列索引

1、**主键索引**：使用Primary Key修饰的字段会自动创建索引(MyISAM（不会自动添加主键）, InnoDB（没有加主键，会默认增加1个整型字段的主键，因为数据和索引是存储在同一个文件中，必须建索引树，然后在索引树上存储数据))  

2、**唯一索引**：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一索引字段可以为null且可以存在多个null值，而主键索引字段不可以为null。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。

3、**多列索引**：在表的多个字段上创建索引 (uid+cid，多列索引必须使用到第一个列，才能用到多列索引，否则索引用不上)  

4、**全文索引**：只能在`CHAR`、`VARCHAR`和`TEXT`类型字段上使用全文索引。

5、**普通索引（二级索引）**：没有任何限制条件，可以给任何类型的字段创建普通索引(创建新表&已创建表，数量是不限的，一张表的一次sql查询只能用一个索引 where a = 1 and  b  =  'M'）。

### 回表了解吗？介绍一下回表操作

二级索引的叶子节点存储的是主键值，如果通过二级索引查询数据，在二级索引的 B+ 树中获取到的是主键值，然后根据主键值到主键索引的 B+ 树叶子节点查找对应的数据，这个过程叫回表，也就是说需要查两个 B+ 树才能查到数据。回表操作是一种较为耗时的操作，因为需要两次磁盘 I/O，可以建立覆盖索引来减少回表次数，提高查询性能。

## 事务

### 什么是事务？事务的四大特性？

一个事务是由一条或者多条对数据库操作的SQL语句所组成的一个不可分割的单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交给数据库；如果有部分事务处理失败，那么事务就要回退到最初的状态，因此，事务要么全部执行成功，要么全部失败。

有的业务需要1条以上的SQL语句共同完成，只有这些SQL都成功了才算业务成功了。

如果其中任意一句SQL由于突然停电，或者系统出错，执行出错了，那么事务就没有提交，事务就回滚，回滚就是数据恢复到事务开始前的状态。这是存储引擎来保证的（redo log 和undo log保证的）。

**事务特性ACID**：**原子性**（`Atomicity`）、**一致性**（`Consistency`）、**隔离性**（`Isolation`）、**持久性**（`Durability`）。

- **原子性**是指当数据修改时，要么全执行，要么全不执行，即不允许事务部分的完成。
- **一致性**是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- **隔离性**。当两个或者多个事务并发执行时，为了保证数据的安全性，将一个事物内部的操作与其它事务的操作隔离起来，不被其它正在执行的事务所看到，使得并发执行的各个事务之间不能互相影响。隔离级别：数据的安全性和事务的并发性。隔离越严格，安全性越高，并发性越低。
- **持久性**是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### InnoDB 引擎用什么技术保证事务的 ACID 呢？

用 undo log（回滚日志）保证原子性；

用 redo log（重做日志）保证持久性；

用 MVCC（多版本并发控制）保证隔离性；

一致性是 ACID 的目的，只要保证原子性、隔离性、持久性，也就保证了数据的一致性。

### 事务隔离级别有哪些？

**事务并发存在的问题：事务处理如果不经隔离，并发执行事务时通常会发生以下的问题：**

- **脏读**：是指在一个事务处理过程里读取了另一个未提交的事务中的数据。此时读取的是无效的脏数据。(脏读必须杜绝，其他下面的情况是事务已经提交了，不能算有问题，解不解决是看业务的需求！！！通过设置不同的隔离级别！！！）
- **不可重复读**：一个事务的操作导致另一个事务前后两次读取到不同的数据。当事务A和事务B并发执行时，当事务B查询读取数据后，事务A更新操作更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样。（事务B读取了事务A已提交的数据）
- **幻读：**一个事务的操作导致另一个事务前后两次查询的结果数据量不同。例如 当事务A和事务B并发执行时，当事务B查询读取数据后，事务A新增或者删除了一条满足事务B查询条件的记录，此时事务B再去查询，发现查询到前一次不存在的记录，或者前一次查询的一些记录不见了。（事务B读取了事务A新增加的数据或者读不到事务A删除的数据）

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

MySQL数据库为我们提供的四种隔离级别（对事务并发执行的控制）：

- **Read uncommitted** (未提交读)：所有事务都可以看到其他未提交事务的执行结果。
- **Read committed** (已提交读)：一个事务只能看见已经提交事务所做的改变。读取未提交的数据是不允许的。防止脏读。但是这个级别仍然允许不可重复读和幻读产生。
- **Repeatable read** (可重复读)：说明事务保证能够再次读取相同的数据而不会失败，即使其他的事务把这个数据改了，你也不会看到前后两次查询的数据的不同。但是幻读仍然会出现。

- **串行化**：串行化。是最高的事务级别，它防止读脏数据，不可重复读和虚读。串行执行，相当于是单线程操作。所以并发能力最低。

在“可重复读”级别，实际上可以解决部分的虚读问题，但是不能防止update更新产生的虚读问题，要禁止虚读产生，还是需要设置串行化隔离级别。

### 事务隔离级别的实现原理

锁+MVCC
事务-》事务的ACID特性-》事务的隔离性-》事务要能够允许并发执行-》数据的安全性，一致性和并发的效率问题-》事务的隔离级别

串行化-》靠锁实现，通过锁给所有的事务都排个序，并发的效率就太低了，但是数据的安全性高。
未提交读-》没有做任何的并发控制，明知是错误的，造成脏读，数据的安全性最低。优点是并发效率非常高。（多线程的竞态条件)

所以我们一般用的是下面这2个隔离级别：
已提交读
可重复读
这2个隔离级别就结合了数据的安全性，一致性，并发的效率 ，是由MVCC多版本并发控制实现的。（MVCC是已提交读和可重复读的原理，锁是串行化的原理）

### MVCC（多版本并发控制）

我们一般默认工作在事务的中间两级隔离级别：已提交读，可重复读。

InnoDB的事务隔离级别已提交读和可重复读的底层实现原理：MVCC（多版本并发控制）–》并发的读取方式：快照读

InnoDB提供了2种读取操作：锁定读和非锁定读
锁定读就是读取的时候加锁了（S锁或者X锁）
非锁定读就是读取的时候没有加锁，指的就是MVCC提供的快照读–》依赖底层的undo log回滚日志。

事务日志：undo log回滚日志 和 redo log重做日志
ACD（依靠 事务日志 保证的） I（依靠 锁+MVCC 保证的）

undo log回滚日志的主要作用：
1、事务发生错误时回滚rollback ，回滚日志（数据在更新的时候，把改之前的数据存下来在回滚日志中，目的是为了事务万一出错回滚了或者我们手动回滚的时候，能够把最初的数据在回滚日志中找到）
2、提供了MVCC的非锁定读（快照读）—》undo log的原理

undo log回滚日志
undo log：回滚日志，保存了事务发生之前的数据的一个版本，用于事务执行时的回滚操作，同时也是实现多版本并发控制（MVCC）下读操作的关键技术。

事务ID和回滚指针。

输入begin；这个意思就是在窗口上开启一个事务，事务开启的请求最终会发到MySQL server上，MySQL server为每1个事务都会分配一个全局的，不冲突的事务ID。（InnoDB存储引擎分配的，因为它才支持事务）

回滚指针：存放的是地址，这个地址表示的是一个数据的内存的位置，看起来是一个链表，从当前行的指针可以访问到旧数据。

### MySQL 中有哪几种锁，列举一下？

**表级锁&行级锁**
表级锁：对整张表加锁。开销小（因为不用去找表的某一行的记录进行加锁，要修改这张表，直接申请加这张表的锁），加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低。

行级锁：对某行记录加锁。开销大（需要找到表中相应的记录，有搜表搜索引的过程），加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度高。

**排它锁和共享锁**
排它锁（Exclusive），又称为X 锁，写锁。
共享锁（Shared），又称为S 锁，读锁。

(SS之间是可以兼容的，但是SX之间，XX之间是互斥的）

**乐观锁**乐观锁基于这样的假设：冲突在系统中出现的频率较低，因此在数据库事务执行过程中，不会频繁地去锁定资源。相反，它在提交更新的时候才检查是否有其他事务已经修改了数据。

**悲观锁**悲观锁假设冲突是常见的，因此在数据处理过程中，它会主动锁定数据，防止其他事务进行修改。

数据库中的行锁，表锁，读锁，写锁均为悲观锁。

### MySQL 有哪些日志？介绍一下

MYSQL 的日志文件主要包括：

- **错误日志（Error Log）：**记录 MySQL 服务器启动、运行或停止时出现的问题。
- **慢查询日志（Slow Query Log）：**记录执行时间超过 long_query_time 值的所有 SQL 语句。这个时间值是可配置的，默认情况下，慢查询日志功能是关闭的。可以用来识别和优化慢 SQL。
- **一般查询日志（General Query Log）：**记录所有 MySQL 服务器的连接信息及所有的 SQL 语句，不论这些语句是否修改了数据。
- **二进制日志（Binary Log）：**记录了所有修改数据库状态的 SQL 语句，以及每个语句的执行时间，如 insert、update、delete 等，但不包括 select 和 show 这类的操作。主要用于数据备份和主从复制。

InnoDB 存储引擎特有的日志文件：

- **重做日志（Redo Log）：**记录了对于 InnoDB 表的每个写操作，实现了事务的持久性，不是 SQL 级别的，而是物理级别的，主要用于崩溃恢复。
- **回滚日志（Undo Log，或者叫事务日志）：**记录数据被修改前的值，保证了事务的原子性，用于事务的回滚和 MVCC。

### 说说 MySQL 的基础架构

![img](./MySQL面试题.assets/1716014203140-51d4e600-7938-43b8-a6e9-b9ccc15e30e4.jpeg)

MySQL 逻辑架构图主要分三层：

- **客户端：**最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。
- **Server 层：**负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等）都在 Server 层实现。
- **存储引擎层：**负责数据的存储和提取，不同的存储引擎共用一个 Server 层，Server 层通过 API 与存储引擎进行通信。

### 一条 SQL 查询语句在 MySQL 中如何执行的？

![image-20250912100439735](./MySQL面试题.assets/image-20250912100439735.png)

第一步：客户端发送 SQL 查询语句到 MySQL 服务器。

第二步：MySQL 服务器的连接器开始处理这个请求，跟客户端建立连接、获取权限、管理连接。

第三步：**解析器开始对 SQL 语句进行解析**，检查语句是否符合 SQL 语法规则，确保引用的数据库、表和列都存在，并处理 SQL 语句中的名称解析和权限验证。

第四步：**优化器负责确定 SQL 语句的执行计划**，这包括选择使用哪些索引，以及决定表之间的连接顺序等。优化器会尝试找出最高效的方式来执行查询。

第五步：**执行器会调用存储引擎的 API 来进行数据的读写**。

第六步：MySQL 的存储引擎将执行结果返回给客户端

第七步：客户端接收到查询结果，完成这次查询请求。

### 连接查询

表多了，我们有时候要在两个表甚至多个表之间进行查询，一次select涉及到多张表格。 
**如果你是一张一张表select，一个一个取数据的话，是不好的。** 
mysql client 发送一条SQL语句到mysql server，mysql server要做很多校验操作。你发2条不同的SQL，首先，在mysql server处理的流程就要走2遍，而且，1次通信就代表1次完整的TCP的3次握手，整个的处理流程返回结果，和TCP的4次挥手，效率就低了，所以有联合查询。

连接查询分为：内连接查询和外连接查询
外连接查询分为：left左连接查询和right右连接查询

### MySQL基础篇

**MySQL是什么？** 
MySQL是一个传统的RDBM数据库，也就是关系型数据库，广泛应用于OLTP场景。

**你提到了OLTP，能说说它和OLAP的区别是什么吗？** 
OLTP（联机事务处理）是传统的关系型数据库的主要应用，用于基本的、日常的事务处理，例如银行的交易记录； 
而OLAP（联机分析处理）是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供了直观易懂的查询结果。最常见的应用就是复杂的动态报表系统。 
总体来说，OLTP用于日常处理、OLAP用于数据分析。 

**DML是什么呢？** 
DML是数据操作语言，用于检索或者修改数据。我们平常最常用的增删查改就是DML。

**DDL又是什么？** 
DDL是数据定义语言，用于操作数据结构，比如创建表，删除表，更改索引等都是DDL。

**那DCL呢？** 
DCL是数据控制语言，用于定义数据库用户的权限，比如创建用户，授权用户，删除用户等都是DCL。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/251f0665448e9f459e3fcbf96d938c3f.png)

**既然varchar是变长，那是不是设置varchar（1000）一定比varchar（100）好？** 
不是这样的。虽然varchar是变长，在相同长度下，磁盘空间占用一样，将值设置更大一些，弹性空间也更大。但也不是完全没有代价的 
在内存加载的时候，每次都是按最大空间来分配的。显然，在排序场景，或者一些临时表聚合场景，更大空间会产生明显的不利影响。

varchar中的长度不光影响磁盘空间，还会影响在使用时的内存空间，并不是越长越好。

**varchar是变长，char是定长，那能用varchar完全代替char么？** 
不能。varchar的优点是更灵活。但是char也不是一无是处的。 
首先，varchar会额外用一个字节存储长度信息，而char则节约了一个字节； 
其次，char的存储空间都是一次性分配的，存储是固定连续的，而varchar的存储的长度是可变的，当varchar更改前后数据长度不一致时，就不可避免的会出现碎片的问题。针对此，需要进行碎片消除作业，也是额外的成本。 
一般来说，长度固定的字段，还是用char比较合适，比如Hash，就很适合用char。

**varchar(11)和int(11)中的11，有什么区别？** 
varcahr中代表能存11个字符，int中只是代表显示长度，对大多数应用没有意义，只是规定一些工具用来显示字符的个数，比如int(1)和int(20)存储和计算其实是一样的。

int(11)的11代表什么，这是个初学者很容易混淆的问题，其实它只是用于显示长度，不会影响存储空间。

**接下来能说说delete和truncate的区别吗？** 
delete是删除行；truncate是整表删除。具体来说，有下面几点区别： 
1.truncate之后，会释放空间；delete之后，不会释放空间，因为delete只是在行上标记删除，后续可以复用； 
2.delete因为是DML，会产生redo log；truncate是DDL则不会； 
3.truncate效率更高； 
4.truncate之后，id从头开始；delete不会。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/259952da0c095546bdc00043507061e9.png)

首先有Innodb引擎，它提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的约束。Innodb的设计目标就是处理大数据容量的数据库系统； 
还有MyIASM引擎，它是原本Mysql的默认引擎，不提供事务的支持，也不支持行级锁和外键； 
最后还有一个MEMORY引擎，它的所有数据都在内存中，数据的处理速度快，但是安全性不高，很少使用。

**那么ACID是什么呢？** 
它是原子性、一致性、隔离性和持久性的缩写。 
原子性，指的是一个事务只有执行成功和失败回滚两种状态，没有中间态；一致性是说数据状态一定是一致的；隔离性是说事务之间互不影响；持久性是指事务执行完成后，对数据所做的操作持久的保存在数据库中。

从一定程序上来讲，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/55b2591e893909705b68751e2ce25f6a.png)

**那么一张表一定有主键吗？** 
是的。一定有。如果主动设置，则采用设置的。否则会自动生成一个默认的行。

**你怎么查看有多少个Sql语句在执行？** 
可以用show processlist，它是显示用户正在运行的线程的命令。需要注意的是，用户都只能看到自己正在运行的线程，除非是root用户，或者专门进行了授权的用户。

